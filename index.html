<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Men√π Mister Tomato</title>
  <link rel="icon" type="image/png" href="public/logo.png">

  <style>
    /* RESET BASE */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      /* Previene il double-tap zoom di default sui link e input e selezioni */
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      /* Rimuove l'evidenziazione al tap su mobile */
      -webkit-tap-highlight-color: transparent;
    }

    body {
      font-family: "Helvetica Neue", Arial, sans-serif;
      background-image: url('public/SfondoTomato.png'); /* Inserisci qui il percorso della tua immagine */
      background-size: cover; /* L'immagine coprir√† l'intera area, tagliando se necessario */
      background-position: center center; /* Centra l'immagine */
      background-repeat: no-repeat; /* Impedisce che l'immagine si ripeta */
      background-attachment: fixed; /* Mantiene l'immagine fissa durante lo scroll */
      color: #333;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      overflow-x: hidden;
      /* Migliora lo scrolling su iOS */
      -webkit-overflow-scrolling: touch;
      /* Permette lo scroll verticale sul body, il pinch-zoom sar√† gestito da JS nell'overlay */
      touch-action: pan-y;
    }

    a {
      text-decoration: none;
    }

    h1 {
      font-size: 2rem;
      margin-bottom: 1.5rem;
      text-align: center;
      color: #d8342c;
      letter-spacing: 1px;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
    }

    .button-container {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      width: 80%;
      max-width: 300px;
      padding-bottom: 2rem;
    }

    button {
      padding: 1rem;
      font-size: 1.1rem;
      font-weight: bold;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    button:active {
      transform: scale(0.97);
    }

    .view-btn {
      background: #d8342c;
      color: #fff;
      box-shadow: 0 4px 10px rgba(216, 52, 44, 0.3);
    }

    .download-btn {
      background: #fff;
      color: #d8342c;
      border: 2px solid #d8342c;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
      display: block;
      margin: 0 auto;
    }

    /* OVERLAY MENU */
    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(255, 255, 255, 0.98);
      display: none;
      flex-direction: column;
      overflow-y: auto; /* Permette lo scroll nativo nell'overlay */
      z-index: 1000;
      padding: 1rem;
      animation: fadeIn 0.3s ease;
      /* Di default l'overlay permette lo scroll verticale e pan-x, pinch-zoom gestito da JS */
      touch-action: pan-y pan-x;
      -webkit-overflow-scrolling: touch;
    }

    .overlay.active {
      display: flex;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .close-btn {
      position: sticky;
      top: 15px;
      /* Calcola la posizione a destra, tenendo conto del padding */
      right: 1rem; 
      align-self: flex-end;
      font-size: 1.8rem;
      background: none;
      border: none;
      cursor: pointer;
      color: #d8342c;
      font-weight: bold;
      z-index: 1100;
      padding: 0 5px;
    }

    .menu-images {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      padding-top: 1rem;
      padding-bottom: 2rem;
      transform-origin: center center;
      transition: transform 0.3s ease-out;
      will-change: transform;
    }

    .menu-images img {
      width: 100%;
      max-width: 500px;
      height: auto;
      border-radius: 10px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
      /* Le immagini di per s√© non intercettano eventi touch per evitare conflitti */
      pointer-events: none;
    }

    @media (min-width: 600px) {
      h1 {
        font-size: 2.5rem;
      }
      .menu-images img {
        max-width: 600px;
      }
    }

    .logo {
  display: block;
  margin: 0 auto 1rem auto; /* Centra e aggiunge spazio sotto */
  max-width: 250px; /* Modifica a piacere */
  height: auto;
}
.logo-testo {
  display: block;
  margin: 0 auto 1.5rem auto; /* Centra e aggiunge spazio sotto */
  max-width: 300px; /* Modifica in base alla larghezza desiderata */
  height: auto;
}

.banner-text {
  width: calc(100% - 1cm); /* lascia mezzo cm di margine su entrambi i lati */
  margin: 0.5cm auto; /* centra orizzontalmente */
  text-align: center;
  background: rgba(255, 255, 255, 0.9);
  padding: 0.5rem;
  border-radius: 8px;
  font-size: 1.2rem;
  font-weight: bold;
  box-shadow: 0 2px 6px rgba(0,0,0,0.2);
}

.banner-text .line1,
.banner-text .line2 {
  display: block; /* forza le righe separate */
  white-space: nowrap; /* impedisce che la riga si spezzi */
}



  </style>
</head>
<body>

  <img src="public/logo.png" alt="Logo Mister Tomato" class="logo">

  <img src="public/logo_testo.png" alt="Logo Testo Mister Tomato" class="logo-testo">


  <div class="button-container">
    <button class="view-btn" id="viewMenuBtn">üçΩÔ∏è Visualizza Men√π</button>
    <!-- Assicurati che il percorso del PDF sia corretto rispetto al file HTML -->
    <a href="public/MenuMisterTomato.pdf" download="MisterTomatoMenu.pdf">
      <button class="download-btn">‚¨áÔ∏è Scarica PDF del men√π</button>
    </a>
  </div>

  <div class="overlay" id="menuOverlay">
    <button class="close-btn" id="closeMenuBtn">‚úï</button>
    <div class="menu-images" id="menuImages"></div>
  </div>

  <script>
    const viewBtn = document.getElementById('viewMenuBtn');
    const closeBtn = document.getElementById('closeMenuBtn');
    const overlay = document.getElementById('menuOverlay');
    const menuImagesContainer = document.getElementById('menuImages');

    // Genera automaticamente le immagini 1.png - 16.png
    for (let i = 1; i <= 16; i++) {
      const img = document.createElement('img');
      img.src = `public/foto/${i}.png`;
      img.alt = `Pagina ${i}`;
      menuImagesContainer.appendChild(img);
    }

    // Mostra overlay
    viewBtn.addEventListener('click', () => {
      overlay.classList.add('active');
      document.body.style.overflow = 'hidden'; // Impedisce lo scroll del body
      // Resetta lo zoom e la posizione quando si apre l'overlay
      currentScale = 1;
      currentX = 0;
      currentY = 0;
      updateTransform();
      menuImagesContainer.style.transition = 'none'; // Rimuove transizione per reset immediato
    });

    // Chiudi overlay
    closeBtn.addEventListener('click', () => {
      overlay.classList.remove('active');
      document.body.style.overflow = ''; // Ripristina lo scroll del body
      // Resetta lo zoom e la posizione anche alla chiusura
      currentScale = 1;
      currentX = 0;
      currentY = 0;
      updateTransform();
      menuImagesContainer.style.transition = 'transform 0.3s ease-out'; // Ripristina transizione
    });

    /* --- Gestione Zoom & Pan (Pinch & Double-Tap) --- */
    let currentScale = 1;
    let currentX = 0;
    let currentY = 0;
    let startPinchDistance = 0;
    let lastTap = 0;
    let startTouches = []; // Per tenere traccia dei punti iniziali del touch per il pan

    function getDistance(touch1, touch2) {
      const dx = touch2.clientX - touch1.clientX;
      const dy = touch2.clientY - touch1.clientY;
      return Math.hypot(dx, dy);
    }

    function getMidpoint(touch1, touch2) {
      return {
        x: (touch1.clientX + touch2.clientX) / 2,
        y: (touch1.clientY + touch2.clientY) / 2
      };
    }

    function updateTransform() {
      requestAnimationFrame(() => {
        menuImagesContainer.style.transform = `translate(${currentX}px, ${currentY}px) scale(${currentScale})`;
        // Se siamo zoomati, disabilitiamo lo scroll nativo per gestire il pan con un dito
        overlay.style.overflowY = currentScale > 1 ? 'hidden' : 'auto';
      });
    }

    overlay.addEventListener('touchstart', (e) => {
      if (e.touches.length === 2) {
        e.preventDefault(); // Previeni lo scroll o altri comportamenti di default
        startPinchDistance = getDistance(e.touches[0], e.touches[1]);
        // Salva le posizioni iniziali dei tocchi per il calcolo del punto di pinch
        startTouches = [{x: e.touches[0].clientX, y: e.touches[0].clientY}, 
                        {x: e.touches[1].clientX, y: e.touches[1].clientY}];
        menuImagesContainer.style.transition = 'none'; // Rimuovi transizione durante il pinch
      } else if (e.touches.length === 1) {
        const currentTime = new Date().getTime();
        const tapLength = currentTime - lastTap;
        if (tapLength < 300 && tapLength > 0) { // Doppio tap
          e.preventDefault();
          const targetScale = currentScale === 1 ? 2 : 1; // Zoom 2x o reset

          menuImagesContainer.style.transition = 'transform 0.3s ease-out'; // Abilita transizione
          
          if (targetScale === 1) { // Reset zoom
            currentScale = 1;
            currentX = 0;
            currentY = 0;
          } else { // Zoom in
            // Centra lo zoom sul punto del doppio tap
            const touchX = e.touches[0].clientX;
            const touchY = e.touches[0].clientY;
            const rect = menuImagesContainer.getBoundingClientRect();

            // Calcola il nuovo offset per centrare lo zoom
            const viewportMidX = rect.left + rect.width / 2;
            const viewportMidY = rect.top + rect.height / 2;

            currentX = (touchX - viewportMidX) * (1 - targetScale);
            currentY = (touchY - viewportMidY) * (1 - targetScale);

            currentScale = targetScale;
          }
          updateTransform();
        }
        lastTap = currentTime;

        // Inizia la modalit√† pan se gi√† zoomato
        if (currentScale > 1) {
          isPanning = true;
          startTouches = [{x: e.touches[0].clientX, y: e.touches[0].clientY}];
          initialX = currentX;
          initialY = currentY;
          menuImagesContainer.style.transition = 'none'; // Rimuovi transizione durante il pan
        }
      }
    }, { passive: false });

    overlay.addEventListener('touchmove', (e) => {
      if (e.touches.length === 2) { // Pinch-to-zoom
        e.preventDefault();
        const currentPinchDistance = getDistance(e.touches[0], e.touches[1]);
        const scaleFactor = currentPinchDistance / startPinchDistance;
        let newScale = currentScale * scaleFactor;

        // Limita lo zoom
        newScale = Math.min(Math.max(0.7, newScale), 4); // Min 0.7x, Max 4x

        // Calcola il punto di riferimento del pinch relativo al container
        const pinchMidX = getMidpoint(startTouches[0], startTouches[1]).x;
        const pinchMidY = getMidpoint(startTouches[0], startTouches[1]).y;
        
        const currentMidX = getMidpoint(e.touches[0], e.touches[1]).x;
        const currentMidY = getMidpoint(e.touches[0], e.touches[1]).y;

        // Applica traslazione per mantenere il punto di pinch centrato
        const dx = (currentMidX - pinchMidX);
        const dy = (currentMidY - pinchMidY);

        currentX += dx;
        currentY += dy;

        currentScale = newScale;
        startPinchDistance = currentPinchDistance; // Aggiorna per il prossimo frame
        startTouches = [{x: e.touches[0].clientX, y: e.touches[0].clientY}, 
                        {x: e.touches[1].clientX, y: e.touches[1].clientY}];

        updateTransform();
      } else if (e.touches.length === 1 && isPanning && currentScale > 1) { // Pan con un dito
        e.preventDefault();
        const dx = e.touches[0].clientX - startTouches[0].x;
        const dy = e.touches[0].clientY - startTouches[0].y;

        let newX = initialX + dx;
        let newY = initialY + dy;

        // Calcola i limiti del pan per evitare di vedere lo sfondo
        const rect = menuImagesContainer.getBoundingClientRect();
        const containerRect = overlay.getBoundingClientRect(); // Contenitore visibile

        const imgScaledWidth = rect.width; // Gi√† scalato
        const imgScaledHeight = rect.height; // Gi√† scalato

        const maxX = Math.max(0, (imgScaledWidth - containerRect.width) / 2);
        const maxY = Math.max(0, (imgScaledHeight - containerRect.height) / 2);

        // Limita il pan sull'asse X
        if (imgScaledWidth > containerRect.width) {
          currentX = Math.max(Math.min(newX, maxX), -maxX);
        } else {
          currentX = 0; // Centra se l'immagine √® pi√π piccola della viewport
        }

        // Limita il pan sull'asse Y
        if (imgScaledHeight > containerRect.height) {
          currentY = Math.max(Math.min(newY, maxY), -maxY);
        } else {
          currentY = 0; // Centra se l'immagine √® pi√π piccola della viewport
        }
        updateTransform();
      }
    }, { passive: false });

    overlay.addEventListener('touchend', (e) => {
      isPanning = false;
      menuImagesContainer.style.transition = 'transform 0.3s ease-out'; // Ripristina transizione
      
      // Se dopo un pinch o pan la scala √® vicina a 1, resettala a 1 e centra
      if (currentScale < 1.05 && currentScale > 0.95) { // Tolleranza
          currentScale = 1;
          currentX = 0;
          currentY = 0;
          updateTransform();
      }
    });

  </script>
  
<!-- AVVISO DOPPIO TAP -->
<div id="zoomHint" style="
  position: fixed;
  top: 15px;
  left: 0;
  right: 0;
  margin: 0 8px;                /* üî∏ Mezzo cm circa ai lati */
  background: rgba(0, 0, 0, 0.85);
  color: white;
  padding: 12px 20px;
  border-radius: 15px;
  font-size: 1rem;
  font-weight: 500;
  text-align: center;
  z-index: 2000;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.5s ease;
  line-height: 1.4;
">
  <span style="display:block; white-space: nowrap;">üîç Tocca due volte per ingrandire l'immagine</span>
  <span style="display:block; white-space: nowrap;">üëÜüèº Trascina con un dito per spostarti</span>
</div>




<script>
  const zoomHint = document.getElementById('zoomHint');
  let zoomHintShown = false;

  function showZoomHint() {
    if (zoomHintShown) return; // Lo mostra solo la prima volta
    zoomHintShown = false;
    zoomHint.style.opacity = '1';
    setTimeout(() => {
      zoomHint.style.opacity = '0';
    }, 10000);
  
  }

  viewBtn.addEventListener('click', () => {
    showZoomHint();
  });
</script>

</body>
</html>
